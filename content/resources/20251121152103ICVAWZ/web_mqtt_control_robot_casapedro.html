<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Control Robot via MQTT - Interfaz</title>
  <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    :root{
      --bg:#f6f7fb;--card:#fff;--text:#222;--muted:#666;--accent:#2563eb;
    }
    [data-theme="dark"]{--bg:#0b1220;--card:#0f1724;--text:#e6eef8;--muted:#9fb0d1;--accent:#60a5fa}

    body{font-family:Inter,system-ui,Segoe UI,Arial; margin:0; background:var(--bg); color:var(--text);}
    .app{max-width:1100px;margin:24px auto;padding:20px;}
    .top{display:flex;gap:16px;align-items:center;justify-content:space-between;margin-bottom:18px}
    .card{background:var(--card);box-shadow:0 6px 18px rgba(2,6,23,0.12);border-radius:12px;padding:14px}

    /* Botones de movimiento */
    .controls{display:flex;gap:8px}
    .controls button{padding:12px 16px;border-radius:10px;border:none;background:var(--accent);color:white;font-weight:600;cursor:pointer}
    .controls button.secondary{background:transparent;color:var(--text);border:1px solid rgba(0,0,0,0.06)}

    /* Interfaz de conexión */
    .connect-form{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    .connect-form input, .connect-form select{padding:8px;border-radius:8px;border:1px solid rgba(0,0,0,0.08)}

    .layout{display:grid;grid-template-columns:1fr 360px;gap:16px}

    /* Área de gráficas */
    .chart-area{min-height:360px}

    /* Panel derecho */
    .panel{display:flex;flex-direction:column;gap:12px}
    .sensors-list{display:grid;grid-template-columns:1fr 1fr;gap:8px}
    .sensor-item{padding:10px;border-radius:8px;background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);}
    .small{font-size:12px;color:var(--muted)}
    .big{font-weight:700;font-size:18px}

    /* Grabación */
    .rec-indicator{display:flex;gap:10px;align-items:center}
    .dot{width:12px;height:12px;border-radius:50%;background:#ef4444;box-shadow:0 0 0 rgba(239,68,68,0.7);animation:none}
    .dot.pulse{animation:recPulse 1s infinite}
    @keyframes recPulse{0%{box-shadow:0 0 0 0 rgba(239,68,68,0.6)}70%{box-shadow:0 0 0 12px rgba(239,68,68,0)}100%{box-shadow:0 0 0 0 rgba(239,68,68,0)}}

    footer{margin-top:18px;text-align:center;color:var(--muted);font-size:13px}

    @media(max-width:900px){.layout{grid-template-columns:1fr} .panel{order:2}}
  </style>
</head>
<body data-theme="light">
  <div class="app">
    <div class="top">
      <h2>Control robot + Gráficas MQTT</h2>
      <div style="display:flex;gap:10px;align-items:center">
        <label class="small">Tema</label>
        <select id="themeSelect">
          <option value="light">Claro</option>
          <option value="dark">Oscuro</option>
        </select>
      </div>
    </div>

    <div class="card connect card-row">
      <div class="connect-form">
        <label class="small">Broker</label>
        <input id="brokerHost" placeholder="host" value="79.117.55.87" />
        <input id="brokerPort" placeholder="puerto" value="9001" style="width:80px" />
        <select id="protocol">
          <option value="wss">wss</option>
          <option value="ws">ws</option>
        </select>
        <input id="username" placeholder="usuario" />
        <input id="password" placeholder="contraseña" type="password" />
        <button id="connectBtn">Conectar</button>
        <div id="connStatus" style="margin-left:12px; font-weight:600; color:var(--muted)">Desconectado</div>
      </div>
    </div>

    <div class="layout">
      <div>
        <div class="card">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px">
            <div>
              <div class="small">Controles de movimiento (publican en topic <code>movimiento</code>)</div>
            </div>
            <div class="rec-indicator" style="height:34px">
              <div id="recDot" class="dot"></div>
              <div id="recText" class="small" style="color:var(--muted)">No grabando</div>
            </div>
          </div>

          <div style="display:flex;gap:8px;flex-wrap:wrap">
            <div class="controls">
              <button data-cmd="adelante">▲ Adelante</button>
              <button data-cmd="atras">▼ Atrás</button>
              <button data-cmd="izquierda">◀ Izquierda</button>
              <button data-cmd="derecha">▶ Derecha</button>
            </div>
            <div style="margin-left:auto;display:flex;gap:8px">
              <button id="startRec" class="secondary">Iniciar grabación</button>
              <button id="exportCsv">Exportar CSV</button>
            </div>
          </div>
        </div>

        <div class="card chart-area" style="margin-top:14px">
          <canvas id="sensorsChart" height="220"></canvas>
        </div>
      </div>

      <aside class="panel">
        <div class="card">
          <h4>Últimos valores</h4>
          <div class="sensors-list" style="margin-top:8px">
            <div class="sensor-item"><div class="small">Luz</div><div id="val-luz" class="big">—</div></div>
            <div class="sensor-item"><div class="small">Sonido</div><div id="val-sonido" class="big">—</div></div>
            <div class="sensor-item"><div class="small">Temperatura</div><div id="val-temperatura" class="big">—</div></div>
            <div class="sensor-item"><div class="small">Humedad</div><div id="val-humedad" class="big">—</div></div>
            <div class="sensor-item" style="grid-column:1/3"><div class="small">Distancia</div><div id="val-distancia" class="big">—</div></div>
          </div>
        </div>

        <div class="card">
          <h4>Estado MQTT</h4>
          <div class="small">Topics suscritos:</div>
          <ul id="subsList" class="small">
            <li>sensors/luz</li>
            <li>sensors/sonido</li>
            <li>sensors/temperatura</li>
            <li>sensors/humedad</li>
            <li>sensors/distancia</li>
          </ul>
        </div>

        <div class="card">
          <h4>Notas</h4>
          <div class="small">Asegúrate de que Mosquitto tenga habilitado WebSockets (puerto y protocolo). Si usas TLS selecciona <code>wss</code> y el puerto apropiado (ej. 443 o 9001).</div>
        </div>
      </aside>
    </div>

    <footer class="small">Interfaz generada — modifica libremente los topics o estilos.</footer>
  </div>

  <script>
    // --- Config ---
    const TOPICS = {
      luz: 'sensores/luz',
      sonido: 'sensores/sonido',
      temperatura: 'sensores/temperatura',
      humedad: 'sensores/humedad',
      distancia: 'sensores/distancia'
    };
    const MOV_TOPIC = 'movimiento';

    // --- Estado local para grabación y datos ---
    let client = null;
    let recording = false;
    const maxPoints = 120; // cantidad de puntos mostrados

    // Buffer de datos para graficar (arrays con timestamps y valores)
    const dataBuffers = {
      luz: [], sonido: [], temperatura: [], humedad: [], distancia: []
    };

    // Buffer para CSV: guardamos filas completas con timestamp y valores (posible null si falta)
    const csvRows = [];

    // --- UI refs ---
    const connectBtn = document.getElementById('connectBtn');
    const connStatus = document.getElementById('connStatus');
    const brokerHost = document.getElementById('brokerHost');
    const brokerPort = document.getElementById('brokerPort');
    const protocol = document.getElementById('protocol');
    const username = document.getElementById('username');
    const password = document.getElementById('password');

    const recDot = document.getElementById('recDot');
    const recText = document.getElementById('recText');
    const startRecBtn = document.getElementById('startRec');
    const exportBtn = document.getElementById('exportCsv');

    const vals = {
      luz: document.getElementById('val-luz'),
      sonido: document.getElementById('val-sonido'),
      temperatura: document.getElementById('val-temperatura'),
      humedad: document.getElementById('val-humedad'),
      distancia: document.getElementById('val-distancia')
    };

    // Chart.js setup: un solo lienzo con varias datasets
    const ctx = document.getElementById('sensorsChart').getContext('2d');
    const sensorsChart = new Chart(ctx, {
      type: 'line',
      data: {
        labels: [],
        datasets: [
          {label:'Luz', data:[], tension:0.2, pointRadius:0},
          {label:'Sonido', data:[], tension:0.2, pointRadius:0},
          {label:'Temperatura', data:[], tension:0.2, pointRadius:0},
          {label:'Humedad', data:[], tension:0.2, pointRadius:0},
          {label:'Distancia', data:[], tension:0.2, pointRadius:0}
        ]
      },
      options:{
        animation:false,
        responsive:true,
        plugins:{legend:{position:'top'}},
        scales:{x:{display:true,title:{display:false}}}
      }
    });

    // Helper: push value to buffer with timestamp
    function pushSensorValue(key, value){
      const now = new Date();
      const t = now.toISOString();
      const num = Number(value);
      if (isNaN(num)) return; // ignorar

      const buf = dataBuffers[key];
      buf.push({t,value:num});
      if (buf.length>maxPoints) buf.shift();

      // actualizar última lectura visual
      vals[key].textContent = value;

      // si estamos grabando añadimos una fila completa (unificamos valores en el momento)
      if (recording){
        const row = { timestamp: t };
        for (const k of Object.keys(TOPICS)){
          // tomar el último valor disponible en el buffer
          const b = dataBuffers[k];
          row[k] = b.length? b[b.length-1].value : '';
        }
        csvRows.push(row);
      }

      updateChart();
    }

    // Actualiza Chart.js con buffers actuales
    function updateChart(){
      // tomar labels a partir del buffer más largo (o sincronizar timestamps)
      // para simplicidad, usamos timestamps del buffer de temperatura si existe, si no la más larga
      let labels = [];
      // buscamos el buffer con más puntos
      let longest = [];
      for (const k of Object.keys(dataBuffers)){
        if (dataBuffers[k].length > longest.length) longest = dataBuffers[k];
      }
      labels = longest.map(p=>new Date(p.t).toLocaleTimeString());

      sensorsChart.data.labels = labels;
      const sets = sensorsChart.data.datasets;
      const keys = Object.keys(dataBuffers);
      for (let i=0;i<keys.length;i++){
        const arr = dataBuffers[keys[i]].map(p=>p.value);
        // si el array es más corto que labels, rellenamos con null para mantener index
        const padded = Array(labels.length - arr.length).fill(null).concat(arr);
        sets[i].data = padded;
      }
      sensorsChart.update('none');
    }

    // Publicar movimiento
    function publishMovement(cmd){
      if (!client || client.disconnected) { alert('No conectado al broker'); return; }
      client.publish(MOV_TOPIC, cmd, {qos:0}, (err)=>{
        if (err) console.error('publish error', err); else console.log('Publicado',MOV_TOPIC,cmd);
      });
    }

    // Conectar al broker usando MQTT over WebSockets
    function connectMQTT(){
      if (client && !client.disconnected) client.end(true);
      const host = brokerHost.value.trim();
      const port = brokerPort.value.trim();
      const proto = protocol.value;
      const url = `${proto}://${host}:${port}`;

      connStatus.textContent = 'Conectando...';

      const opts = {
        username: username.value || undefined,
        password: password.value || undefined,
        reconnectPeriod: 2000,
        connectTimeout: 30*1000
      };

      try{
        client = mqtt.connect(url, opts);
      }catch(err){
        connStatus.textContent = 'Error URL';
        console.error(err); return;
      }

      client.on('connect', ()=>{
        connStatus.textContent = 'Conectado';
        // suscribimos a los topics de sensores
        for (const k of Object.keys(TOPICS)){
          client.subscribe(TOPICS[k], {qos:0}, (err)=>{
            if (err) console.warn('subscribe error',err);
          });
        }
      });
      client.on('reconnect', ()=> connStatus.textContent='Reconectando...');
      client.on('close', ()=> connStatus.textContent='Cerrado');
      client.on('error', (e)=>{ connStatus.textContent='Error'; console.error(e); });

      client.on('message', (topic, payload)=>{
        const text = payload.toString();
        // mapear topic a clave
        for (const k of Object.keys(TOPICS)){
          if (topic === TOPICS[k]){ pushSensorValue(k, text); break; }
        }
      });
    }

    // CSV export
    function exportCSV(){
      if (csvRows.length===0){
        alert('No hay datos grabados. Inicia la grabación antes de exportar.');
        return;
      }
      // construir CSV con header: timestamp + keys
      const keys = ['timestamp', ...Object.keys(TOPICS)];
      const lines = [keys.join(',')];
      for (const r of csvRows){
        const row = keys.map(k=> (r[k]===undefined||r[k]==='')? '' : String(r[k]) );
        lines.push(row.join(','));
      }
      const blob = new Blob([lines.join('\n')], {type:'text/csv;charset=utf-8;'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = `sensores_${new Date().toISOString()}.csv`;
      document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    }

    // UI wiring
    document.querySelectorAll('[data-cmd]').forEach(b=>{
      b.addEventListener('click', ()=> publishMovement(b.dataset.cmd));
    });
    connectBtn.addEventListener('click', connectMQTT);

    startRecBtn.addEventListener('click', ()=>{
      recording = !recording;
      if (recording){
        csvRows.length = 0; // limpiar
        startRecBtn.textContent = 'Detener grabación';
        recDot.classList.add('pulse'); recText.textContent = 'Grabando...';
      } else {
        startRecBtn.textContent = 'Iniciar grabación';
        recDot.classList.remove('pulse'); recText.textContent = 'No grabando';
      }
    });

    exportBtn.addEventListener('click', exportCSV);

    // Tema
    const themeSelect = document.getElementById('themeSelect');
    themeSelect.addEventListener('change', ()=>{
      document.body.setAttribute('data-theme', themeSelect.value);
    });

    // conexion automatica con valores por defecto al cargar (OPCIONAL)
    // connectMQTT();

    // Nota: asegúrate de que Mosquitto esté configurado para WebSockets y que el puerto coincida.
  </script>
</body>
</html>
